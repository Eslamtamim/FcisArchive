@inject ApplicationDbContext _dbcontext
@inject IMemoryCache cache

<div class="">
    @if (subjects is null)
    {
        <h6> loading... </h6>
    }
    else if (subjects!.Count() > 0)
    {
        <br />
        <div class="m-3 d-flex flex-wrap justify-content-sm-around align-content-center  subjects">

            @foreach (var subject in subjectsMap)
            {
                <div class="">
                    <h3 class="text-black text-decoration-underline fw-bold text-center" @onclick="() => toggleLectuers = !toggleLectuers">@subject.Key</h3>

                    @foreach (var lecture in subject.Value)
                    {
                        <a class="btn btn-outline-secondary fw-bold m-2 p-2" href="/s/@subject.Key/@lecture">
                            @lecture
                        </a>
                        <br />
                    }

                </div>
            }

        </div>
    }
    else
    {
        <h4 class="alert-danger">
            there are no files got uploaded yet, contact the Admin to upload or try uploading yourself
        </h4>
    }
</div>



@code {

    public List<string> subjects { get; set; }
    public Dictionary<string, List<string>> subjectsMap { get; set; } = new();
    bool toggleLectuers = false;
    List<string> errors = new List<string>();
    protected override Task OnInitializedAsync()
    {
        try
        {
            // cacheing the subjects for 1 day	, if the cache is empty it will be filled
            subjects = cache.GetOrCreate("subjects", entry =>
            {
                entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromDays(1);
                return _dbcontext.lectures.Select(s=> s.Name).ToList();
            });
            foreach (var subject in subjects)
            {
                var subjectName = subject.Split('-').First();
                if (subjectsMap.GetValueOrDefault(subjectName) is null) subjectsMap.Add(subjectName, new List<string>());
                subjectsMap[subjectName].Add(subject);
            }
        }
        catch (Exception e)
        {
            errors.Add(e.Message);
            errors.Add(e.ToString());
        }

        return base.OnInitializedAsync();
}
}
