@page "/s/{subject}/{LectureName}"

@inject UserManager<StudentUser> userManager
@inject SignInManager<StudentUser> signInManager
@inject NavigationManager navigation
@inject AuthenticationStateProvider GetAuthenticationStateAsync
@inject ApplicationDbContext _dbcontext
@inject IMemoryCache cache

<div>

    <div class="d-flex align-content-between justify-content-between">
        <h1 class="fw-bold">@LectureName.Replace('-', ' ').Replace("Lec", "Lecture")</h1>
        <AuthorizeView>
            <div>
                <button class="btn d-inline btn-warning" @onclick="ResetQuestionsAnswers">Reset All Answers</button>
                <AuthorizeView Context="childContext" Roles="Super-Admin, Admin">
                    <button class="btn d-inline btn-danger" @onclick="DeleteQuestionsBySubject">Delete This Lecture</button>
                </AuthorizeView>
            </div>
        </AuthorizeView>

    </div>
    @* <p class="alert-warning" style="width:fit-content">This is a demo version of the app, due to the cost of the
    database, questions are limited to only 20 but the count is accurate </p>*@

    @if (_errors.Count > 0)
    {
        @foreach (var error in _errors)
        {
            <p class="my-0 text-danger">@error</p>
        }
    }
    @if (FilteredQuestions is null)
    {
        <Loading/>
    }
    else if (FilteredQuestions!.Count == 0)
    {
        <div class="alert alert-danger" role="alert">
            no questions yet
        </div>
    }
    else
    {
        <div class="d-flex @(_errors.Count > 0 ? "justify-content-between" : "justify-content-end") ">
            @if (_errors.Count > 0)
            {
                <div class="d-flex m-3">
                    <a class="btn mx-3 btn-secondary" href="Account/Register">Register</a>
                    <a class="btn btn-outline-secondary " href="Account/Login">Log in</a>
                </div>
            }
            <p style="font-size: 25px " class="fw-bolder">
                Amount of Questions :
                <span class="alert-info">
                    @QuestionCount
                </span>
            </p>
        </div>
        foreach (var question in FilteredQuestions!)
        {
            <QuestionCard Question="@question" IsAuthorized="@(UserName is not null)"
                          StudentAnswer="@(FindStudentAnswer.TryGetValue(question.Id, out var value) ? value : null)"
                          StudentUser="@StudentUser"/>
        }
    }

</div>


@code {

    [Parameter]
    public string LectureName { get; set; }

    [Parameter]
    public string Subject { get; set; }

    //public record StudentAnswersDTO(string StudentId, long questionId, long answerId);

    List<Question> FilteredQuestions { get; set; }
    List<StudentQuestionAnswer> StudentAnswers { get; set; } = new();

    Dictionary<long, StudentQuestionAnswer> FindStudentAnswer { get; set; } = new();
    readonly List<string> _errors = new List<string>();
    AuthenticationState UserAuth { get; set; }
    StudentUser StudentUser { get; set; }
    Lecture Lecture { get; set; }
    long QuestionCount { get; set; }
    string UserName { get; set; }

    protected override async Task OnInitializedAsync()
    {
        UserAuth = await GetAuthenticationStateAsync.GetAuthenticationStateAsync();

        if (UserAuth.User.Identity != null) UserName = UserAuth.User.Identity.Name;

        if (UserName is null)
        {
            _errors.Add("you are not logged in");
            _errors.Add("login to save the state of your answers");
        }
        else
        {
            StudentUser = await userManager.FindByNameAsync(UserName);
            Lecture = await _dbcontext.lectures.FirstOrDefaultAsync(l => l.Name == LectureName);
            StudentAnswers = await GetStudentQuestionAnswers();
            foreach (var sq in StudentAnswers) FindStudentAnswer[sq.questionId] = sq;
        }

        QuestionCount = cache.GetOrCreate<long>("questionCount" + LectureName, entry =>
        {
            entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromDays(1);
            return _dbcontext.questions.LongCount(q => q.Lecture.Name == LectureName);
        });
        
        FilteredQuestions = await cache.GetOrCreateAsync('q'+LectureName, async entry =>
        {
            entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromDays(1);
            return await GetQuestions(LectureName);
        });
       

    //cache the question count for 1 day


        await base.OnInitializedAsync();
    }


    async Task<List<Question>> GetQuestions(string lectureName)
    {
        try
        {
            if (string.IsNullOrEmpty(lectureName))
            {
                return new List<Question>();
            }


            List<Question> result = new();
            const int databaseSelectionChunk = 300;

            for (var i = 0; i < QuestionCount / databaseSelectionChunk; i++)
            {
                var query = await _dbcontext.questions
                    .Where(q => q.Lecture.Name == lectureName)
                    .Include(q => q.answers)
                    .OrderBy(q => q.Id)
                    .AsSplitQuery()
                    .Skip(i * databaseSelectionChunk)
                    .Take(databaseSelectionChunk)
                    .ToListAsync();

                result.AddRange(query);
            }

            var skipLast = (int)databaseSelectionChunk * (int)(QuestionCount / databaseSelectionChunk);
            var takeLast = (int)QuestionCount % databaseSelectionChunk;

            var lastQuery = await _dbcontext.questions
                .Where(q => q.Lecture.Name == lectureName)
                .OrderBy(q => q.Id)
                .Include(q => q.answers)
                .AsSplitQuery()
                .Skip(skipLast)
                .Take(takeLast)
                .ToListAsync();

            result.AddRange(lastQuery);
            return result;
        }
        catch (Exception e)
        {
            _errors.Add(e.Message);
            return new List<Question>();
        }
    }

    async Task<List<StudentQuestionAnswer>> GetStudentQuestionAnswers()
    {
        return await _dbcontext.studentQuestionAnswer
            .Where(q => q.question.LectureId == Lecture.Id
                        && q.studentsId == StudentUser.Id).ToListAsync();
    }

    async Task DeleteQuestionsBySubject()
    {
        try
        {
    // just delete the lecture and the questions will be deleted by cascade
            var qs = _dbcontext.lectures.FirstOrDefault(l => l.Name == LectureName);
            if (qs != null) _dbcontext.lectures.Remove(qs);
            var subjectYear = _dbcontext.subjects.FirstOrDefault(s => s.Name == Subject)!.Year;
            cache.Remove("subjects" + (int)subjectYear);
            cache.Remove("questionCount" + LectureName);
            cache.Remove('q' + LectureName);
            await _dbcontext.SaveChangesAsync();
            navigation.NavigateTo(navigation.BaseUri, true, true);
        }
        catch (Exception ex)
        {
            _errors.Add(ex.Message);
            _errors.Add(ex.InnerException?.Message);
        }
    }

    async Task ResetQuestionsAnswers()
    {
        try
        {
            var qs = _dbcontext.studentQuestionAnswer.Where(sqa =>
                sqa.studentsId == StudentUser.Id
                && sqa.question.Lecture.Name == LectureName).ToList();
            _dbcontext.studentQuestionAnswer.RemoveRange(qs);
            await _dbcontext.SaveChangesAsync();
            navigation.NavigateTo(navigation.Uri, true, true);
        }
        catch (Exception ex)
        {
            _errors.Add(ex.Message);
            if (ex.InnerException != null) _errors.Add(ex.InnerException.Message);
        }
    }

}