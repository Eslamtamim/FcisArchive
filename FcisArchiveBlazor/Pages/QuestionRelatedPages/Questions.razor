@page "/s/{subject}/{LectureName}"
@using Microsoft.AspNetCore.WebUtilities

@inject UserManager<StudentUser> userManager
@inject SignInManager<StudentUser> signInManager
@inject NavigationManager navigation
@inject AuthenticationStateProvider GetAuthenticationStateAsync
@inject ApplicationDbContext _dbcontext
@inject IMemoryCache cache

<div>

    <div class="d-flex align-content-between justify-content-between">
        <h1 class="fw-bold">@LectureName.Replace('-', ' ').Replace("Lec", "Lecture")</h1>
        <div>
            <button class="btn btn-outline-primary" @onclick="() => QuestionsByType(null)">All</button>
            <button class="btn btn-outline-secondary" @onclick="() => QuestionsByType(QuestionType.MCQ)">MCQ</button>
            <button class="btn btn-outline-secondary" @onclick="() => QuestionsByType(QuestionType.TrueFalse)">T&F</button>
        </div>
        <AuthorizeView>
            <div>
                <button class="btn d-inline btn-warning" @onclick="ResetQuestionsAnswers">Reset All Answers</button>
                <AuthorizeView Context="childContext" Roles="Super-Admin, Admin">
                    <button class="btn d-inline btn-danger" @onclick="DeleteQuestionsBySubject">Delete This Lecture</button>
                </AuthorizeView>
            </div>
        </AuthorizeView>

    </div>
    @* <p class="alert-warning" style="width:fit-content">This is a demo version of the app, due to the cost of the
    database, questions are limited to only 20 but the count is accurate </p>*@

    @if (_errors.Count > 0)
    {
        @foreach (var error in _errors)
        {
            <p class="my-0 text-danger">@error</p>
        }
    }
    @if (FilteredQuestions is null || isLoading)
    {
        <Loading/>
    }
    else if (FilteredQuestions!.Count == 0)
    {
        <div class="alert alert-danger" role="alert">
            no questions yet
        </div>
    }
    else
    {
        <div class="d-flex align-items-center  @(_errors.Count > 0 ? "justify-content-between" : "justify-content-between") ">
            @if (_errors.Count > 0)
            {
                <div class="d-flex m-3">
                    <a class="btn mx-3 btn-secondary" href="Account/Register">Register</a>
                    <a class="btn btn-outline-secondary " href="Account/Login">Log in</a>
                </div>
            }
        </div>
        <div class="pagesAndCount d-flex justify-content-between align-items-center">
            <div class="d-flex m-4 justify-content-center align-content-center gap-2 align-items-center flex-wrap">

                @foreach (var currentPage in Enumerable.Range(1, (int)pages))
                {
                    <button class=" btn @(page  == currentPage ? "btn-secondary" : "btn-outline-secondary")"  @onclick="() => { SetPage(currentPage); }">
                        @currentPage.ToString()
                    </button>
                }
            </div>
            <p style="font-size: 25px " class="fw-bolder">
                Amount of Questions :
                <span class="alert-info">
                    @QuestionCount
                </span>
            </p>
        </div>
        foreach (var question in FilteredQuestions!)
        {
            <QuestionCard Question="@question" IsAuthorized="@(UserName is not null)"
                          StudentAnswer="@(FindStudentAnswer.TryGetValue(question.Id, out var value) ? value : null)"
                          StudentUser="@StudentUser"/>
        }
    }


</div>


@code {

    [Parameter]
    public string LectureName { get; set; }

    [Parameter]
    public string Subject { get; set; }

    //public record StudentAnswersDTO(string StudentId, long questionId, long answerId);

    List<Question> FilteredQuestions { get; set; }
    List<StudentQuestionAnswer> StudentAnswers { get; set; } = new();

    Dictionary<long, StudentQuestionAnswer> FindStudentAnswer { get; set; } = new();
    readonly List<string> _errors = new List<string>();
    AuthenticationState UserAuth { get; set; }
    StudentUser StudentUser { get; set; }
    Lecture Lecture { get; set; }
    int page = 1;
    decimal pages = 1;
        const int DatabaseSelectionChunk = 20;
    bool isLoading = false;
    long QuestionCount { get; set; }
    string UserName { get; set; }


    protected override async Task OnInitializedAsync()
    {
        var uri = navigation.ToAbsoluteUri(navigation.Uri);
        var queryStrings = QueryHelpers.ParseQuery(uri.Query);
        if (queryStrings.TryGetValue("page", out var currentPage))
        {
            page = int.TryParse(currentPage, out var result) ? result : 1;
            if (page < 1) page = 1;
        }
        else
        {
            navigation.NavigateTo(navigation.Uri + $"?page={page}", true);
        }

        UserAuth = await GetAuthenticationStateAsync.GetAuthenticationStateAsync();
        if (UserAuth.User.Identity != null) UserName = UserAuth.User.Identity.Name;
        if (UserName is null)
        {
            _errors.Add("you are not logged in");
            _errors.Add("login to save the state of your answers");
        }
        else
        {
            StudentUser = await userManager.FindByNameAsync(UserName);
            Lecture = await _dbcontext.lectures.FirstOrDefaultAsync(l => l.Name == LectureName);
            StudentAnswers = await GetStudentQuestionAnswers();
            foreach (var sq in StudentAnswers) FindStudentAnswer[sq.questionId] = sq;
        }
    //cache the question count for 1 day
        QuestionCount = cache.GetOrCreate<long>("questionCount" + LectureName, entry =>
        {
            entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromDays(1);
            return _dbcontext.questions.LongCount(q => q.Lecture.Name == LectureName);
        });
        pages = (decimal)QuestionCount / DatabaseSelectionChunk;
        pages = Math.Ceiling(pages);
        FilteredQuestions = await cache.GetOrCreateAsync($"p{page}" + LectureName, async entry =>
        {
            entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromDays(1);
            return await GetQuestions(LectureName);
        });


        await base.OnInitializedAsync();
    }


    async Task<List<Question>> GetQuestions(string lectureName)
    {
        try
        {
            if (string.IsNullOrEmpty(lectureName))
            {
                return new List<Question>();
            }


            List<Question> result = new();


            var query = await _dbcontext.questions
                .Where(q => q.Lecture.Name == lectureName)
                .Include(q => q.answers)
                .OrderBy(q => q.Id)
                .Skip((page - 1) * DatabaseSelectionChunk)
                .Take(DatabaseSelectionChunk)
                .ToListAsync();

            result.AddRange(query);


    // var skipLast = (int)databaseSelectionChunk * (int)(QuestionCount / databaseSelectionChunk);
    // var takeLast = (int)QuestionCount % databaseSelectionChunk;
    //
    // var lastQuery = await _dbcontext.questions
    //     .Where(q => q.Lecture.Name == lectureName)
    //     .OrderBy(q => q.Id)
    //     .Include(q => q.answers)
    //     .AsSplitQuery()
    //     .Skip(skipLast)
    //     .Take(takeLast)
    //     .ToListAsync();
    //
    // result.AddRange(lastQuery);
            return result;
        }
        catch (Exception e)
        {
            _errors.Add(e.Message);
            return new List<Question>();
        }
    }

    async Task<List<StudentQuestionAnswer>> GetStudentQuestionAnswers()
    {
        return await _dbcontext.studentQuestionAnswer
            .Where(q => q.question.LectureId == Lecture.Id
                        && q.studentsId == StudentUser.Id).ToListAsync();
    }

    async Task DeleteQuestionsBySubject()
    {
        try
        {
    // just delete the lecture and the questions will be deleted by cascade
            var qs = _dbcontext.lectures.FirstOrDefault(l => l.Name == LectureName);
            if (qs != null) _dbcontext.lectures.Remove(qs);
            var subjectYear = _dbcontext.subjects.FirstOrDefault(s => s.Name == Subject)!.Year;
            cache.Remove("subjects" + (int)subjectYear);
            cache.Remove("lectures" + Subject);
            cache.Remove("questionCount" + LectureName);
            cache.Remove($"p{page}" + LectureName);
            await _dbcontext.SaveChangesAsync();
            navigation.NavigateTo(navigation.BaseUri, true, true);
        }
        catch (Exception ex)
        {
            _errors.Add(ex.Message);
            _errors.Add(ex.InnerException?.Message);
        }
    }

    async Task QuestionsByType(QuestionType? type)
    {
        isLoading = true;
        QuestionCount = cache.GetOrCreate<long>("questionCount" + LectureName, entry =>
        {
            entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromDays(1);
            return _dbcontext.questions.LongCount(q => q.Lecture.Name == LectureName);
        });
        FilteredQuestions = await cache.GetOrCreateAsync($"q{page}" + LectureName, async entry =>
        {
            entry.AbsoluteExpirationRelativeToNow = TimeSpan.FromDays(1);
            return await GetQuestions(LectureName);
        });

        if (type is null)
        {
      
            if (StudentUser is not null) StudentAnswers = await GetStudentQuestionAnswers();
            isLoading = false;
            StateHasChanged();
            return;
        }
        if (StudentUser is not null){

        StudentAnswers = await _dbcontext.studentQuestionAnswer
            .Where(q => q.question.LectureId == Lecture.Id
                        && q.studentsId == StudentUser.Id
                        && q.question.QuestionType == type).ToListAsync();
        }

        FilteredQuestions = FilteredQuestions.Where(q => q.QuestionType == type).ToList();
        QuestionCount = FilteredQuestions.Count;
        isLoading = false;
        StateHasChanged();
    }

    async Task ResetQuestionsAnswers()
    {
        try
        {
            var qs = _dbcontext.studentQuestionAnswer.Where(sqa =>
                sqa.studentsId == StudentUser.Id
                && sqa.question.Lecture.Name == LectureName).ToList();
            _dbcontext.studentQuestionAnswer.RemoveRange(qs);
            await _dbcontext.SaveChangesAsync();
            navigation.NavigateTo(navigation.Uri, true, true);
        }
        catch (Exception ex)
        {
            _errors.Add(ex.Message);
            if (ex.InnerException != null) _errors.Add(ex.InnerException.Message);
        }
    }

    void SetPage(int currentPage)
    {
        var queryParams = new Dictionary<string, string>
        {
            ["page"] = currentPage.ToString()
        };
        navigation.NavigateTo(QueryHelpers.AddQueryString($"/s/{Subject}/{LectureName}", queryParams), true);
    }

}

